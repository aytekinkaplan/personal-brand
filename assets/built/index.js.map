{"version":3,"file":"index.js","sources":["../js/infiniteScroll.js","../js/menuOpen.js","../js/index.js","../js/slider.js"],"sourcesContent":["/*\r\nThis script continously loads post as the user scrolls the page. It uses the IntersectionObserver API to detect when the last post is in view. When the last post is in view, it fetches the next page and appends the posts to the page. It then checks if there is a next page and if there is, it continues to observe the last post. If there is no next page, it disconnects the observer. \r\n\r\nImportantly, for this script to work, it requires that each card have the `post` class and that the card container have the `gh-postfeed` class\r\n*/\r\n\r\nlet link = document.querySelector('link[rel=\"next\"]')?.getAttribute(\"href\");\r\n\r\n// Fetch and parse next page\r\nasync function getNextPage(url) {\r\n    try {\r\n        const res = await fetch(url);\r\n\r\n        if (!res.ok) {\r\n            throw new Error(\"Failed to fetch page\");\r\n        }\r\n\r\n        const nextPageHtml = await res.text();\r\n        const parser = new DOMParser();\r\n        const parsed = parser.parseFromString(nextPageHtml, \"text/html\");\r\n        const posts = parsed.querySelectorAll(\".post\");\r\n        const nextLink = parsed\r\n            .querySelector('link[rel=\"next\"]')\r\n            ?.getAttribute(\"href\");\r\n\r\n        return { posts, nextLink };\r\n    } catch (error) {\r\n        throw new Error(error);\r\n    }\r\n}\r\n\r\nexport default function infiniteScroll() {\r\n    if (!link) {\r\n        return;\r\n    }\r\n\r\n    const options = {\r\n        // When the last card is within a 150px of the viewport, fetch the next page. This provides a smoother transition between pages\r\n        rootMargin: \"150px\",\r\n    };\r\n\r\n    const callback = (entries, observer) => {\r\n        try {\r\n            entries.forEach((entry) => {\r\n                if (entry.isIntersecting) {\r\n                    if (link) {\r\n                        getNextPage(link).then(({ posts, nextLink }) => {\r\n                            posts.forEach((post) => {\r\n                                document\r\n                                    .querySelector(\".gh-postfeed\")\r\n                                    .append(post);\r\n                            });\r\n\r\n                            if (nextLink) {\r\n                                link = nextLink;\r\n                                observer.observe(\r\n                                    document.querySelector(\".post:last-of-type\")\r\n                                );\r\n                            } else {\r\n                                observer.disconnect();\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        } catch (error) {\r\n            console.log(error);\r\n        }\r\n    };\r\n\r\n    let observer = new IntersectionObserver(callback, options);\r\n\r\n    observer.observe(document.querySelector(\".post:last-of-type\"));\r\n}\r\n","// Toggle the menu open and close when on mobile\r\nexport default function menuOpen() {\r\n    const burgerButton = document.querySelector(\".gh-burger\");\r\n    burgerButton.addEventListener(\"click\", function () {\r\n        document.body.classList.toggle(\"gh-head-open\");\r\n    });\r\n}\r\n","// Import JS\r\nimport menuOpen from \"./menuOpen\";\r\nimport infiniteScroll from \"./infiniteScroll\";\r\nimport { initSliders } from \"./slider\"; // Güncellenmiş slider fonksiyonunu import ettik\r\n\r\n// Call the menu, infinite scroll, and slider functions\r\nmenuOpen();\r\ninfiniteScroll();\r\ninitSliders(); // Çoklu slider fonksiyonunu başlat\r\n","export function initSliders() {\r\n    // Select all sliders on the page\r\n    const sliders = document.querySelectorAll(\".gh-slider\");\r\n\r\n    sliders.forEach((slider, index) => {\r\n        // Get the navigation buttons for the current slider\r\n        const prevBtn = slider.parentElement.querySelector(\".prev-btn\");\r\n        const nextBtn = slider.parentElement.querySelector(\".next-btn\");\r\n        const sliderItems = Array.from(\r\n            slider.querySelectorAll(\".gh-slider-item\")\r\n        );\r\n\r\n        // Exit if any necessary element is missing\r\n        if (!slider || !prevBtn || !nextBtn || sliderItems.length === 0) return;\r\n\r\n        // Configuration for the slider\r\n        const itemsVisible = 3;\r\n        const itemWidth = 100 / itemsVisible;\r\n        const totalItems = sliderItems.length;\r\n        const maxIndex = totalItems - itemsVisible;\r\n        let currentIndex = 0;\r\n        let autoSlideInterval;\r\n\r\n        // Sort slider items by date (newest first)\r\n        sliderItems.sort(\r\n            (a, b) => new Date(b.dataset.date) - new Date(a.dataset.date)\r\n        );\r\n\r\n        // Clear and append sorted items\r\n        slider.innerHTML = \"\";\r\n        sliderItems.forEach((item) => {\r\n            item.style.width = `${itemWidth}%`; // Set item width based on visibility\r\n            slider.appendChild(item);\r\n        });\r\n\r\n        updateSlider();\r\n\r\n        // Add event listeners\r\n        nextBtn.addEventListener(\"click\", moveNext);\r\n        prevBtn.addEventListener(\"click\", movePrev);\r\n        window.addEventListener(\"resize\", updateSlider); // Update slider on window resize\r\n        addSwipeEvents(slider);\r\n        addKeyboardNavigation();\r\n        startAutoSlide();\r\n\r\n        function moveNext() {\r\n            if (currentIndex < maxIndex) currentIndex++;\r\n            updateSlider();\r\n        }\r\n\r\n        function movePrev() {\r\n            if (currentIndex > 0) currentIndex--;\r\n            updateSlider();\r\n        }\r\n\r\n        function updateSlider() {\r\n            const offset = currentIndex * itemWidth;\r\n            slider.style.transform = `translateX(-${offset}%)`;\r\n            slider.style.transition = \"transform 0.6s ease-in-out\";\r\n\r\n            // Toggle visibility of navigation buttons\r\n            prevBtn.style.display = currentIndex === 0 ? \"none\" : \"flex\";\r\n            nextBtn.style.display = currentIndex >= maxIndex ? \"none\" : \"flex\";\r\n        }\r\n\r\n        function addSwipeEvents(sliderElement) {\r\n            let startX = 0;\r\n            let isDragging = false;\r\n\r\n            sliderElement.addEventListener(\"touchstart\", (e) => {\r\n                startX = e.touches[0].clientX;\r\n                isDragging = true;\r\n                clearInterval(autoSlideInterval); // Stop auto-slide while dragging\r\n            });\r\n\r\n            sliderElement.addEventListener(\"touchmove\", (e) => {\r\n                if (!isDragging) return;\r\n                const touchX = e.touches[0].clientX;\r\n                const diffX = startX - touchX;\r\n                const translateX =\r\n                    (-currentIndex * slider.clientWidth) / itemsVisible - diffX;\r\n                slider.style.transform = `translateX(${translateX}px)`;\r\n            });\r\n\r\n            sliderElement.addEventListener(\"touchend\", (e) => {\r\n                isDragging = false;\r\n                const endX = e.changedTouches[0].clientX;\r\n                const threshold = 50; // Minimum swipe distance\r\n\r\n                if (startX - endX > threshold && currentIndex < maxIndex)\r\n                    moveNext();\r\n                else if (endX - startX > threshold && currentIndex > 0)\r\n                    movePrev();\r\n                else updateSlider();\r\n\r\n                startAutoSlide(); // Restart auto-slide after touch event\r\n            });\r\n        }\r\n\r\n        function addKeyboardNavigation() {\r\n            document.addEventListener(\"keydown\", (e) => {\r\n                if (e.key === \"ArrowLeft\") movePrev();\r\n                if (e.key === \"ArrowRight\") moveNext();\r\n            });\r\n        }\r\n\r\n        function startAutoSlide() {\r\n            autoSlideInterval = setInterval(() => {\r\n                if (currentIndex >= maxIndex) currentIndex = 0;\r\n                else currentIndex++;\r\n                updateSlider();\r\n            }, 5000); // Slide every 5 seconds\r\n        }\r\n    });\r\n}\r\n"],"names":["link","document","querySelector","getAttribute","addEventListener","body","classList","toggle","IntersectionObserver","callback","entries","observer","forEach","entry","isIntersecting","async","url","res","fetch","ok","Error","nextPageHtml","text","parsed","DOMParser","parseFromString","posts","querySelectorAll","nextLink","error","getNextPage","then","_ref","post","append","observe","disconnect","console","log","rootMargin","infiniteScroll","slider","index","prevBtn","parentElement","nextBtn","sliderItems","Array","from","length","itemWidth","maxIndex","autoSlideInterval","currentIndex","moveNext","updateSlider","movePrev","offset","style","transform","transition","display","startAutoSlide","setInterval","sort","a","b","Date","dataset","date","innerHTML","item","width","appendChild","window","sliderElement","startX","isDragging","e","touches","clientX","clearInterval","touchX","diffX","translateX","clientWidth","endX","changedTouches","addSwipeEvents","key"],"mappings":"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"}