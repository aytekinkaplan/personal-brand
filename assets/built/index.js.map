{"version":3,"file":"index.js","sources":["../js/infiniteScroll.js","../js/menuOpen.js","../js/index.js","../js/slider.js"],"sourcesContent":["/*\r\nThis script continously loads post as the user scrolls the page. It uses the IntersectionObserver API to detect when the last post is in view. When the last post is in view, it fetches the next page and appends the posts to the page. It then checks if there is a next page and if there is, it continues to observe the last post. If there is no next page, it disconnects the observer. \r\n\r\nImportantly, for this script to work, it requires that each card have the `post` class and that the card container have the `gh-postfeed` class\r\n*/\r\n\r\nlet link = document.querySelector('link[rel=\"next\"]')?.getAttribute(\"href\");\r\n\r\n// Fetch and parse next page\r\nasync function getNextPage(url) {\r\n    try {\r\n        const res = await fetch(url);\r\n\r\n        if (!res.ok) {\r\n            throw new Error(\"Failed to fetch page\");\r\n        }\r\n\r\n        const nextPageHtml = await res.text();\r\n        const parser = new DOMParser();\r\n        const parsed = parser.parseFromString(nextPageHtml, \"text/html\");\r\n        const posts = parsed.querySelectorAll(\".post\");\r\n        const nextLink = parsed\r\n            .querySelector('link[rel=\"next\"]')\r\n            ?.getAttribute(\"href\");\r\n\r\n        return { posts, nextLink };\r\n    } catch (error) {\r\n        throw new Error(error);\r\n    }\r\n}\r\n\r\nexport default function infiniteScroll() {\r\n    if (!link) {\r\n        return;\r\n    }\r\n\r\n    const options = {\r\n        // When the last card is within a 150px of the viewport, fetch the next page. This provides a smoother transition between pages\r\n        rootMargin: \"150px\",\r\n    };\r\n\r\n    const callback = (entries, observer) => {\r\n        try {\r\n            entries.forEach((entry) => {\r\n                if (entry.isIntersecting) {\r\n                    if (link) {\r\n                        getNextPage(link).then(({ posts, nextLink }) => {\r\n                            posts.forEach((post) => {\r\n                                document\r\n                                    .querySelector(\".gh-postfeed\")\r\n                                    .append(post);\r\n                            });\r\n\r\n                            if (nextLink) {\r\n                                link = nextLink;\r\n                                observer.observe(\r\n                                    document.querySelector(\".post:last-of-type\")\r\n                                );\r\n                            } else {\r\n                                observer.disconnect();\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        } catch (error) {\r\n            console.log(error);\r\n        }\r\n    };\r\n\r\n    let observer = new IntersectionObserver(callback, options);\r\n\r\n    observer.observe(document.querySelector(\".post:last-of-type\"));\r\n}\r\n","// Toggle the menu open and close when on mobile\r\nexport default function menuOpen() {\r\n    const burgerButton = document.querySelector(\".gh-burger\");\r\n    burgerButton.addEventListener(\"click\", function () {\r\n        document.body.classList.toggle(\"gh-head-open\");\r\n    });\r\n}\r\n","// index.js\r\n\r\n// Import CSS\r\nimport \"../css/index.css\";\r\n\r\n// Import JS\r\nimport menuOpen from \"./menuOpen\";\r\nimport infiniteScroll from \"./infiniteScroll\";\r\nimport { initSlider } from \"./slider\"; // Slider fonksiyonunu import ettik\r\n\r\n// Call the menu, infinite scroll, and slider functions\r\nmenuOpen();\r\ninfiniteScroll();\r\ninitSlider(); // Slider fonksiyonunu başlat\r\n","export function initSlider() {\r\n    const slider = document.querySelector(\".gh-slider\");\r\n    const prevBtn = document.querySelector(\".prev-btn\");\r\n    const nextBtn = document.querySelector(\".next-btn\");\r\n    const sliderItems = Array.from(\r\n        document.querySelectorAll(\".gh-slider-item\")\r\n    );\r\n\r\n    // Elemanların mevcut olup olmadığını kontrol et\r\n    if (!slider || !prevBtn || !nextBtn || sliderItems.length === 0) return;\r\n\r\n    const itemsVisible = 3; // Aynı anda görüntülenen slayt sayısı\r\n    const itemWidth = 100 / itemsVisible; // Her elemanın slider içindeki yüzdesel genişliği\r\n    const totalItems = sliderItems.length; // Toplam eleman sayısı\r\n    const maxIndex = totalItems - itemsVisible; // maxIndex değeri: Tüm elemanlar eksi görünür eleman sayısı\r\n    let currentIndex = 0; // Başlangıç olarak en güncel 3 post zaten gösterildiğinden, currentIndex = 0 olarak ayarlıyoruz\r\n\r\n    // Slider öğelerini tarihe göre sıralayalım (en güncel tarih ilk olacak şekilde)\r\n    sliderItems.sort((a, b) => {\r\n        const dateA = new Date(a.getAttribute(\"data-date\")); // \"data-date\" özelliğini kullanarak tarih alıyoruz\r\n        const dateB = new Date(b.getAttribute(\"data-date\"));\r\n        return dateB - dateA; // En güncel tarih önce gelir\r\n    });\r\n\r\n    // Slider içindeki elemanları temizleyip, sıralanmış elemanları ekliyoruz\r\n    slider.innerHTML = \"\"; // Mevcut slider içeriğini temizle\r\n    sliderItems.forEach((item) => slider.appendChild(item)); // Tüm postları slider'a ekle\r\n\r\n    // Sayfa yüklendiğinde slider'ı güncelle\r\n    updateSlider();\r\n\r\n    // Sağ oka tıklama işlemi\r\n    nextBtn.addEventListener(\"click\", () => {\r\n        if (currentIndex < maxIndex) {\r\n            currentIndex++;\r\n            updateSlider();\r\n        }\r\n    });\r\n\r\n    // Sol oka tıklama işlemi\r\n    prevBtn.addEventListener(\"click\", () => {\r\n        if (currentIndex > 0) {\r\n            currentIndex--;\r\n            updateSlider();\r\n        }\r\n    });\r\n\r\n    function updateSlider() {\r\n        // Offset, slaytın ne kadar kayacağını belirler\r\n        const offset = currentIndex * itemWidth; // Her seferde %33.33 kayma yerine itemWidth kullandık\r\n        slider.style.transform = `translateX(-${offset}%)`;\r\n\r\n        // Sol ok butonu başlangıçta gizli olacak\r\n        prevBtn.style.display = currentIndex === 0 ? \"none\" : \"flex\";\r\n\r\n        // Sağ ok butonu en son postta gizlenecek\r\n        nextBtn.style.display = currentIndex >= maxIndex ? \"none\" : \"flex\";\r\n    }\r\n}\r\n"],"names":["link","document","querySelector","getAttribute","addEventListener","body","classList","toggle","IntersectionObserver","callback","entries","observer","forEach","entry","isIntersecting","async","url","res","fetch","ok","Error","nextPageHtml","text","parsed","DOMParser","parseFromString","posts","querySelectorAll","nextLink","error","getNextPage","then","_ref","post","append","observe","disconnect","console","log","rootMargin","infiniteScroll","slider","prevBtn","nextBtn","sliderItems","Array","from","length","itemWidth","maxIndex","currentIndex","updateSlider","offset","style","transform","display","sort","a","b","dateA","Date","innerHTML","item","appendChild","initSlider"],"mappings":"8SAMA,IAAIA,EAAOC,SAASC,cAAc,qBAAqBC,aAAa,QCJ3CF,SAASC,cAAc,cAC/BE,iBAAiB,SAAS,WACnCH,SAASI,KAAKC,UAAUC,OAAO,eACnC,ID0BW,WACX,IAAKP,EACD,OAqCW,IAAIQ,sBA7BFC,CAACC,EAASC,KACvB,IACID,EAAQE,SAASC,IACTA,EAAMC,gBACFd,GApCxBe,eAA2BC,GACvB,IACI,MAAMC,QAAYC,MAAMF,GAExB,IAAKC,EAAIE,GACL,MAAM,IAAIC,MAAM,wBAGpB,MAAMC,QAAqBJ,EAAIK,OAEzBC,GADS,IAAIC,WACGC,gBAAgBJ,EAAc,aAC9CK,EAAQH,EAAOI,iBAAiB,SAChCC,EAAWL,EACZrB,cAAc,qBACbC,aAAa,QAEnB,MAAO,CAAEuB,QAAOE,WACnB,CAAC,MAAOC,GACL,MAAM,IAAIT,MAAMS,EACpB,CACJ,CAiBwBC,CAAY9B,GAAM+B,MAAKC,IAAyB,IAAxBN,MAAEA,EAAKE,SAAEA,GAAUI,EACvCN,EAAMd,SAASqB,IACXhC,SACKC,cAAc,gBACdgC,OAAOD,EAAK,IAGjBL,GACA5B,EAAO4B,EACPjB,EAASwB,QACLlC,SAASC,cAAc,wBAG3BS,EAASyB,YACb,GAGZ,GAEP,CAAC,MAAOP,GACLQ,QAAQC,IAAIT,EAChB,IA/BY,CAEZU,WAAY,UAkCPJ,QAAQlC,SAASC,cAAc,sBAC5C,CE7DAsC,GCZO,WACH,MAAMC,EAASxC,SAASC,cAAc,cAChCwC,EAAUzC,SAASC,cAAc,aACjCyC,EAAU1C,SAASC,cAAc,aACjC0C,EAAcC,MAAMC,KACtB7C,SAAS0B,iBAAiB,oBAI9B,IAAKc,IAAWC,IAAYC,GAAkC,IAAvBC,EAAYG,OAAc,OAEjE,MACMC,EAAY,IADG,EAGfC,EADaL,EAAYG,OAFV,EAIrB,IAAIG,EAAe,EAgCnB,SAASC,IAEL,MAAMC,EAASF,EAAeF,EAC9BP,EAAOY,MAAMC,UAAY,eAAeF,MAGxCV,EAAQW,MAAME,QAA2B,IAAjBL,EAAqB,OAAS,OAGtDP,EAAQU,MAAME,QAAUL,GAAgBD,EAAW,OAAS,MAChE,CAvCAL,EAAYY,MAAK,CAACC,EAAGC,KACjB,MAAMC,EAAQ,IAAIC,KAAKH,EAAEtD,aAAa,cAEtC,OADc,IAAIyD,KAAKF,EAAEvD,aAAa,cACvBwD,CAAK,IAIxBlB,EAAOoB,UAAY,GACnBjB,EAAYhC,SAASkD,GAASrB,EAAOsB,YAAYD,KAGjDX,IAGAR,EAAQvC,iBAAiB,SAAS,KAC1B8C,EAAeD,IACfC,IACAC,IACJ,IAIJT,EAAQtC,iBAAiB,SAAS,KAC1B8C,EAAe,IACfA,IACAC,IACJ,GAcR,CD7CAa"}